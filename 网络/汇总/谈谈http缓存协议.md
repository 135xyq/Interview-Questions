# 谈谈http缓存协议

缓存是指浏览器对请求过的资源会进行存储，当再次请求时可以直接使用本地缓存而不用重复向服务器发送请求，大大减轻了服务器压力并且减少了网络流量。

缓存一般由响应头中的expires, cache-control , last-Modified , Etag字段来进行设置

## expires

在http1.0协议中，与缓存有关的响应头字段只有expires, 它指定了缓存资源的过期时间，该时间为绝对时间。

 此时的缓存逻辑：

- 浏览器第一次向服务器请求某个资源，服务器正常响应数据返回状态码200,并且响应头中有expires字段指定缓存时间。
- 在缓存过期之前，浏览器再次请求相同资源时直接使用缓存。
- 缓存过期后，浏览器再请求该资源时，会重新向服务器发出请求，服务器重新返回资源内容，并且设置新的缓存时间expire

缺点: 

- 一旦缓存过期后，无论缓存的资源是否有变化，服务器都必须重新返回资源内容。

## cache-control

在http1.1协议中，响应头中新出了cache-control字段，该字段有如下值:

- public
- private
- max-age
- no-cache
- no-store

通过设置cache-control的max-age，可以指定缓存资源过期的相对时间，但是这仍然解决不了一旦缓存过期后，无论缓存的资源是否有变化，服务器都必须重新返回资源内容的问题

## last-Modified

服务器在响应头中设置last-Modified字段来告诉浏览器当前缓存资源的上次修改时间。

此时的缓存逻辑为:

- 浏览器第一次向服务器请求某个资源，服务器正常响应数据返回状态码200,并且响应头中有max-age指定缓存时间。
- 在缓存过期之前，浏览器再次请求相同资源时直接使用缓存。
- 缓存过期后，浏览器再请求该资源时，会发出缓存请求，请求头中会附带if-Modified-Since(值为之前响应头中的last-Modified)，服务器接受请求后，会对比资源的上次修改时间是否与请求头中的if-Modified-Since相同，如果相同说明资源，没有变化，直接返回304否则重新返回资源内容，状态码为200。

缺陷: 

- last-Modified只能精确到秒，如果在一秒内，服务器端的某个资源内容发生了改变，这时候浏览器恰巧又发出了缓存请求来请求该资源，这会导致服务器直接返回304让浏览器复用缓存资源而得不到最新资源。
- 有可能资源发生了修改但是资源内容无变化，这会导致浏览器发送缓存请求时，明明资源内容没有变化但是服务器却重新返回资源内容。

## Etag

服务器可以在响应头中设置该字段来指示资源的编号，该编号可以视作资源的唯一ID,只有当资源内容变化时编号才会发生改变

此时的缓存逻辑为:

- 浏览器第一次向服务器请求某个资源，服务器正常响应数据返回状态码200,并且响应头中有max-age指定缓存时间。
- 在缓存过期之前，浏览器再次请求相同资源时直接使用缓存。
- 缓存过期后，浏览器再请求该资源时，会发出缓存请求，请求头中会附带if-None-Match字段(值为之前响应头中的Etag),服务器接受请求后会查看所要请求的缓存资源的编号是否有变化，如无变化则返回304,否则重新返回最新的资源



http缓存协议发展历程: 

因为强缓存有缺点呀，比如说，设置了expires，GMT格式，但是浏览器的时间可以改变，因此就通过cache-control返回一个相对时间来。但是假如说资源并没有更新，但是强缓存时间过期了，那就需要重新拉去资源，因此就有了last-modified，但是last-modified的时间单位是s，当1s内有资源修改，那浏览器返回的最后修改时间和上次的修改时间相同，那就不会重新拉取资源，因此推出了etag，通过比对资源内容来判断是否修改

expire --->  max-age ----> last-modified ---> Etag













